<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGPU Shadertoy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/mode/simple.min.js"></script>
    <style>
      .cm-s-gruvbox-dark-hard.CodeMirror {
        background-color: #1d2021;
        color: #ebdbb2;
        height: 100%;
        overflow-y: auto;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-gutters {
        background-color: #1d2021;
        border-right: 1px solid #3c3836;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-linenumber {
        color: #7c6f64;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-cursor {
        border-left: 1px solid #ebdbb2;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-activeline-background {
        background-color: #3c3836;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-selected {
        background-color: #504945;
      }
      .cm-s-gruvbox-dark-hard span.cm-comment {
        color: #928374;
      }
      .cm-s-gruvbox-dark-hard span.cm-keyword {
        color: #fb4934;
      }
      .cm-s-gruvbox-dark-hard span.cm-operator {
        color: #ebdbb2;
      }
      .cm-s-gruvbox-dark-hard span.cm-string {
        color: #b8bb26;
      }
      .cm-s-gruvbox-dark-hard span.cm-number {
        color: #d3869b;
      }
      #code-editor-container {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      #code-editor-container .CodeMirror {
        flex: 1;
        min-height: 0;
      }
      .CodeMirror-scroll {
        height: 100%;
        overflow-y: auto !important;
        overflow-x: auto !important;
      }
      .num-input {
        width: 60px; padding: 4px; background: #3c3836; color: #ebdbb2;
        border: 1px solid #665c54; border-radius: 4px;
      }
      .control-label { font-size: 12px; color: #fe8019; }
      .object-item {
        padding: 8px; margin-bottom: 8px; background: #3c3836;
        border-left: 3px solid #fe8019; cursor: pointer; border-radius: 4px;
      }
      .object-item:hover { background: #504945; }
      .object-item.selected { background: #504945; border-left-color: #b8bb26; }
      .scroll-container { overflow-y: auto; max-height: 200px; }
    </style>
  </head>
  <body class="font-mono bg-gray-900 text-white overflow-hidden">
    <div class="flex w-screen h-screen gap-0">
      <div class="flex-1 bg-black relative">
        <canvas id="canvas" class="block w-full h-full"></canvas>
        <div id="error-message" class="absolute bottom-2.5 left-2.5 right-2.5 text-red-500 text-xs bg-black/80 p-1.5 rounded hidden max-h-24 overflow-y-auto z-10"></div>
        <div class="absolute top-2.5 left-2.5 text-xs" style="color: #fe8019"><span id="fps">0</span> FPS</div>
      </div>
      
      <div class="w-80 bg-gray-800 flex flex-col border-l border-gray-700 overflow-hidden" style="background: #1d2021">
        <div class="p-3 border-b" style="background: #1d2021; color: #ebdbb2; border-color: #3c3836">
          <h2 class="font-bold mb-2 text-sm">Scene Objects</h2>
          <div class="flex gap-2">
            <button id="add-sphere-btn" class="flex-1 px-2 py-1 text-xs rounded bg-blue-700 hover:bg-blue-600">+ Sphere</button>
            <button id="add-cube-btn" class="flex-1 px-2 py-1 text-xs rounded bg-purple-700 hover:bg-purple-600">+ Cube</button>
          </div>
        </div>

        <div class="flex-1 flex flex-col overflow-hidden">
          <div class="p-3 border-b flex-shrink-0" style="border-color: #3c3836">
            <h3 class="font-bold text-xs mb-2" style="color: #fe8019">Objects</h3>
            <div id="objects-list" class="scroll-container"></div>
          </div>

          <div class="flex-1 overflow-y-auto p-3" id="properties-panel" style="display: none; border-top: 1px solid #3c3836">
            <h3 class="font-bold text-xs mb-3" style="color: #fe8019">Properties</h3>
            <div id="properties-content" class="space-y-3"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('canvas');
      const errorMsg = document.getElementById('error-message');
      let device, context, pipeline, uniformBuffer, bindGroup;
      let startTime = performance.now();
      let lastFrameTime = startTime;
      let frameCount = 0;
      let lastFpsUpdate = startTime;

      let scene = { objects: [], selectedIndex: -1 };
      let objectIdCounter = 0;
      let mouseX = 0;
      let mouseY = 0;
      let mouseDown = false;
      let cameraYaw = 0;
      let cameraPitch = 0.1;
      let cameraDistance = 12.0;

      const vertexShader = `@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
  var pos = array<vec2<f32>, 3>(vec2<f32>(-1.0, -1.0), vec2<f32>(3.0, -1.0), vec2<f32>(-1.0, 3.0));
  return vec4<f32>(pos[vertexIndex], 0.0, 1.0);
}`;

      const uniformsStruct = `struct Object {
  position: vec3<f32>,
  objType: f32,
  color: vec3<f32>,
  scale: f32,
  _padding1: f32,
  _padding2: f32,
  _padding3: f32,
}

struct Uniforms {
  resolution: vec2<f32>, 
  time: f32, 
  deltaTime: f32, 
  mouse: vec4<f32>, 
  frame: u32,
  numObjects: u32,
  _padding2: u32, 
  _padding3: u32,
  objects: array<Object, 10>,
}
@group(0) @binding(0) var<uniform> uniforms: Uniforms;`;

      const fragmentShader = `
const MAX_DIST: f32 = 100.0;
const SURF_DIST: f32 = 0.001;
const MAX_STEPS: i32 = 256;

fn sd_sphere(p: vec3<f32>, r: f32) -> f32 {
  return length(p) - r;
}

fn sd_box(p: vec3<f32>, b: vec3<f32>) -> f32 {
  let q = abs(p) - b;
  return length(max(q, vec3<f32>(0.0))) + min(max(q.x, max(q.y, q.z)), 0.0);
}

fn sd_plane(p: vec3<f32>, n: vec3<f32>, h: f32) -> f32 {
  return dot(p, n) + h;
}

fn get_dist(p: vec3<f32>) -> vec2<f32> {
  var res = vec2<f32>(MAX_DIST, -1.0);

  // Ground plane
  let plane_dist = sd_plane(p, vec3<f32>(0.0, 1.0, 0.0), 2.0);
  if plane_dist < res.x {
    res = vec2<f32>(plane_dist, -2.0);
  }

  // Scene objects
  for (var i = 0u; i < uniforms.numObjects; i++) {
    let obj = uniforms.objects[i];
    let local_p = p - obj.position;
    
    var d: f32;
    if obj.objType < 0.5 {
      // Sphere
      d = sd_sphere(local_p, obj.scale);
    } else {
      // Cube
      d = sd_box(local_p, vec3<f32>(obj.scale));
    }
    
    if d < res.x {
      res = vec2<f32>(d, f32(i));
    }
  }

  return res;
}

fn get_normal(p: vec3<f32>) -> vec3<f32> {
  let e = 0.001;
  let n = vec3<f32>(
    get_dist(p + vec3<f32>(e, 0.0, 0.0)).x - get_dist(p - vec3<f32>(e, 0.0, 0.0)).x,
    get_dist(p + vec3<f32>(0.0, e, 0.0)).x - get_dist(p - vec3<f32>(0.0, e, 0.0)).x,
    get_dist(p + vec3<f32>(0.0, 0.0, e)).x - get_dist(p - vec3<f32>(0.0, 0.0, e)).x
  );
  return normalize(n);
}

fn ray_march(ro: vec3<f32>, rd: vec3<f32>) -> vec2<f32> {
  var d = 0.0;
  var mat_id = -1.0;
  for (var i = 0; i < MAX_STEPS; i++) {
    let p = ro + rd * d;
    let dist_mat = get_dist(p);
    d += dist_mat.x;
    mat_id = dist_mat.y;
    if dist_mat.x < SURF_DIST || d > MAX_DIST {
      break;
    }
  }
  return vec2<f32>(d, mat_id);
}

@fragment
fn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
  let uv = (fragCoord.xy - uniforms.resolution * 0.5) / min(uniforms.resolution.x, uniforms.resolution.y);
  
  let pitch = uniforms.mouse.y / uniforms.resolution.y * 1.5;
  let yaw = uniforms.mouse.x / uniforms.resolution.x * 6.28;
  
  let cam_dist = 4.0;
  let cam_target = vec3<f32>(0.0, 0.0, 0.0);
  let cam_pos = vec3<f32>(sin(yaw) * cos(pitch), sin(pitch), cos(yaw) * cos(pitch)) * cam_dist;
  
  let cam_forward = normalize(cam_target - cam_pos);
  let cam_right = normalize(cross(cam_forward, vec3<f32>(0.0, 1.0, 0.0)));
  let cam_up = cross(cam_right, cam_forward);
  
  let focal_length = 1.5;
  let rd = normalize(cam_right * uv.x - cam_up * uv.y + cam_forward * focal_length);
  
  let result = ray_march(cam_pos, rd);
  
  if result.x < MAX_DIST {
    let hit_pos = cam_pos + rd * result.x;
    let normal = get_normal(hit_pos);
    let light_pos = vec3<f32>(2.0, 5.0, -1.0);
    let light_dir = normalize(light_pos - hit_pos);
    let diffuse = max(dot(normal, light_dir), 0.0);
    
    var color = vec3<f32>(0.5);
    let mat_id = i32(result.y);
    
    if mat_id >= 0 && mat_id < 10 {
      // Use object's custom color
      color = uniforms.objects[u32(mat_id)].color;
    } else if mat_id == -2 {
      let checker = floor(hit_pos.x) + floor(hit_pos.z);
      color = select(vec3<f32>(0.2), vec3<f32>(0.8), i32(checker) % 2 == 0);
    }
    
    let ambient = 0.3;
    let light = ambient + diffuse * 0.7;
    color = color * light;
    
    let fog = exp(-result.x * 0.02);
    let sky_col = mix(vec3<f32>(0.5, 0.7, 1.0), vec3<f32>(0.2, 0.3, 0.5), uv.y * 0.5 + 0.5);
    let final_col = mix(sky_col, color, fog);
    
    return vec4<f32>(final_col, 1.0);
  }
  
  let sky = mix(vec3<f32>(0.5, 0.7, 1.0), vec3<f32>(0.2, 0.3, 0.5), uv.y * 0.5 + 0.5);
  return vec4<f32>(sky, 1.0);
}`;

      async function initWebGPU() {
        if (!navigator.gpu) return ((errorMsg.textContent = "WebGPU not supported"), false);
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) return ((errorMsg.textContent = "No GPU adapter"), false);
        device = await adapter.requestDevice();
        context = canvas.getContext("webgpu");
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });
        uniformBuffer = device.createBuffer({
          size: 2048,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        
        const code = vertexShader + "\n" + uniformsStruct + "\n" + fragmentShader;
        const shaderModule = device.createShaderModule({ code });
        const format2 = navigator.gpu.getPreferredCanvasFormat();
        const bindGroupLayout = device.createBindGroupLayout({
          entries: [{ binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }],
        });
        pipeline = device.createRenderPipeline({
          layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
          vertex: { module: shaderModule, entryPoint: "vs_main" },
          fragment: { module: shaderModule, entryPoint: "fs_main", targets: [{ format: format2 }] },
          primitive: { topology: "triangle-list" },
        });
        bindGroup = device.createBindGroup({
          layout: bindGroupLayout,
          entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
        });
        return true;
      }

      function createObject(type) {
        const typeInt = type === 'sphere' ? 0 : 1;
        
        const obj = {
          id: objectIdCounter++,
          objType: typeInt,
          position: [0, 0, -3 ],
          scale: type === 'sphere' ? 0.5 : 0.4,
          color: [Math.random(), Math.random(), Math.random()]
        };
        scene.objects.push(obj);
        updateObjectsList();
        selectObject(scene.objects.length - 1);
        console.log('Object created:', obj);
      }

      function removeObject(index) {
        scene.objects.splice(index, 1);
        scene.selectedIndex = -1;
        updateObjectsList();
        document.getElementById('properties-panel').style.display = 'none';
      }

      function selectObject(index) {
        scene.selectedIndex = index;
        updateObjectsList();
        updatePropertiesPanel();
      }

      function updateObjectsList() {
        const list = document.getElementById('objects-list');
        list.innerHTML = scene.objects.map((obj, idx) => {
          const typeName = obj.objType === 0 ? 'SPHERE' : 'CUBE';
          return `
          <div class="object-item ${idx === scene.selectedIndex ? 'selected' : ''}" onclick="selectObject(${idx})">
            <div class="flex justify-between items-center">
              <span class="text-xs font-semibold">${typeName} #${obj.id}</span>
              <button onclick="event.stopPropagation(); removeObject(${idx})" class="text-xs px-2 py-0.5 bg-red-700 hover:bg-red-600 rounded">×</button>
            </div>
          </div>
        `}).join('');
      }

      function updatePropertiesPanel() {
  const panel = document.getElementById('properties-panel');
  if (scene.selectedIndex < 0) {
    panel.style.display = 'none';
    return;
  }
  panel.style.display = 'block';
  const obj = scene.objects[scene.selectedIndex];
  
  // Convertir RGB float → hex string
  const toHex = (n) => Math.floor(n * 255).toString(16).padStart(2, '0');
  const colorHex = `#${toHex(obj.color[0])}${toHex(obj.color[1])}${toHex(obj.color[2])}`;
  
  document.getElementById('properties-content').innerHTML = `
    <div class="space-y-3">
      <div>
        <div class="control-label mb-2">Position</div>
        <input type="number" step="0.1" value="${obj.position[0].toFixed(2)}" 
          oninput="updateObjectProperty('position', 0, parseFloat(this.value))" 
          placeholder="X" class="num-input w-full mb-1">
        <input type="number" step="0.1" value="${obj.position[1].toFixed(2)}" 
          oninput="updateObjectProperty('position', 1, parseFloat(this.value))" 
          placeholder="Y" class="num-input w-full mb-1">
        <input type="number" step="0.1" value="${obj.position[2].toFixed(2)}" 
          oninput="updateObjectProperty('position', 2, parseFloat(this.value))" 
          placeholder="Z" class="num-input w-full">
      </div>
      
      <div>
        <div class="control-label mb-2">Scale: <span id="scale-value">${obj.scale.toFixed(2)}</span></div>
        <input type="range" min="0.1" max="3" step="0.1" value="${obj.scale}" 
          oninput="updateObjectProperty('scale', null, parseFloat(this.value))" 
          class="w-full">
      </div>
      
      <div>
        <div class="control-label mb-2">Color</div>
        <input type="color" value="${colorHex}" 
          oninput="updateObjectProperty('color', null, this.value)" 
          class="w-full h-10">
      </div>
    </div>
  `;
}

function updateObjectProperty(prop, index, value) {
  if (scene.selectedIndex < 0) return;
  
  const obj = scene.objects[scene.selectedIndex];
  
  if (prop === 'position') {
    obj.position[index] = value;
  } else if (prop === 'scale') {
    obj.scale = value;

    const scaleValueEl = document.getElementById('scale-value');
    if (scaleValueEl) scaleValueEl.textContent = value.toFixed(2);
  } else if (prop === 'color') {
    const hex = value;
    obj.color = [
      parseInt(hex.substr(1, 2), 16) / 255,
      parseInt(hex.substr(3, 2), 16) / 255,
      parseInt(hex.substr(5, 2), 16) / 255
    ];
  }
}
      function render() {
        if (!pipeline) return;
        
        const currentTime = performance.now();
        const deltaTime = (currentTime - lastFrameTime) / 1000;
        const elapsedTime = (currentTime - startTime) / 1000;
        
        const normalizedMouseX = (cameraYaw % (Math.PI * 2)) / (Math.PI * 2) * canvas.width;
        const normalizedMouseY = cameraPitch / 1.5 * canvas.height;
        
        // Créer le buffer avec les objets
        const bufferData = new Float32Array(512);
        
        // Uniforms de base (8 floats = 32 bytes)
        bufferData[0] = canvas.width;
        bufferData[1] = canvas.height;
        bufferData[2] = elapsedTime;
        bufferData[3] = deltaTime;
        bufferData[4] = normalizedMouseX;
        bufferData[5] = normalizedMouseY;
        bufferData[6] = mouseDown ? 1 : 0;
        bufferData[7] = 0;
        
        // frame et numObjects (8 bytes)
        const intView = new Uint32Array(bufferData.buffer);
        intView[8] = frameCount;
        intView[9] = scene.objects.length;
        
        // Padding (8 bytes)
        bufferData[10] = 0;
        bufferData[11] = 0;
        
        // Objects array commence à l'index 12 (48 bytes offset)
        // Chaque objet = 8 floats = 32 bytes
        for (let i = 0; i < Math.min(scene.objects.length, 10); i++) {
          const obj = scene.objects[i];
          const offset = 12 + i * 12;
          
          bufferData[offset + 0] = obj.position[0];
          bufferData[offset + 1] = obj.position[1];
          bufferData[offset + 2] = obj.position[2];
          bufferData[offset + 3] = obj.objType;
          bufferData[offset + 4] = obj.color[0];
          bufferData[offset + 5] = obj.color[1];
          bufferData[offset + 6] = obj.color[2];
          bufferData[offset + 7] = obj.scale;
        }
        
        device.queue.writeBuffer(uniformBuffer, 0, bufferData);

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
          colorAttachments: [{
            view: context.getCurrentTexture().createView(),
            loadOp: "clear",
            clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1 },
            storeOp: "store",
          }],
        });
        
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.draw(3);
        pass.end();
        device.queue.submit([encoder.finish()]);

        lastFrameTime = currentTime;
        if (++frameCount && currentTime - lastFpsUpdate > 100) {
          const fps = Math.round(frameCount / ((currentTime - lastFpsUpdate) / 1_000));
          document.getElementById("fps").textContent = fps;
          frameCount = 0;
          lastFpsUpdate = currentTime;
        }

        requestAnimationFrame(render);
      }

      function resizeCanvas() {
        const rect = canvas.parentElement.getBoundingClientRect();
        const dpr = devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";
      }

      document.getElementById('add-sphere-btn').onclick = () => createObject('sphere');
      document.getElementById('add-cube-btn').onclick = () => createObject('cube');

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const dpr = devicePixelRatio || 1;
        mouseX = (e.clientX - rect.left) * dpr;
        mouseY = (e.clientY - rect.top) * dpr;
      });
      canvas.addEventListener("mousedown", () => (mouseDown = true));
      canvas.addEventListener("mouseup", () => (mouseDown = false));
      canvas.addEventListener("mouseleave", () => (mouseDown = false));

      const keys = {};
      window.addEventListener("keydown", (e) => {
        keys[e.key] = true;
        if (e.key === "ArrowLeft") cameraYaw += 0.05;
        if (e.key === "ArrowRight") cameraYaw -= 0.05;
        if (e.key === "ArrowUp") cameraPitch = Math.min(cameraPitch - 0.05, 1.5);
        if (e.key === "ArrowDown") cameraPitch = Math.max(cameraPitch + 0.05, 0.05);
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
      });

      window.addEventListener("resize", resizeCanvas);

      const main = async () => {
        resizeCanvas();
        if (await initWebGPU()) render();
      };
      main();
    </script>
  </body>
</html>